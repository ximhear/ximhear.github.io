<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Point Cloud Viewer - 240만 점</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #canvas {
            flex: 1;
            display: block;
            cursor: grab;
        }
        #canvas:active {
            cursor: grabbing;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group:last-child {
            margin-bottom: 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        input[type="range"] {
            width: 200px;
        }
        input[type="file"] {
            font-size: 12px;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        #info div {
            margin-bottom: 5px;
        }
        #info div:last-child {
            margin-bottom: 0;
        }
        .value {
            color: #4CAF50;
            font-weight: bold;
        }
        button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }
        button:hover {
            background: #1976D2;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="controls">
            <div class="control-group">
                <label>데이터 파일 (Float32 Binary)</label>
                <input type="file" id="fileInput" accept=".bin">
                <button id="generateSample">샘플 데이터 생성</button>
            </div>
            
            <div class="control-group">
                <label>색상</label>
                <input type="color" id="pointColor" value="#00ff00">
            </div>
            
            <div class="control-group">
                <button id="resetView">뷰 리셋</button>
            </div>
        </div>
        
        <div id="info">
            <div>점 개수: <span class="value" id="pointCount">0</span></div>
            <div>FPS: <span class="value" id="fps">0</span></div>
            <div>줌: <span class="value" id="zoomLevel">1.0</span>x</div>
        </div>
        
        <div id="loading">로딩 중...</div>
    </div>

    <script>
        class PointCloudViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.pointCount = 0;
                this.pointColor = [0, 1, 0]; // RGB
                
                // 카메라 상태
                this.camera = {
                    x: 0,
                    y: 0,
                    zoom: 1.0
                };
                
                // 마우스 상태
                this.mouse = {
                    down: false,
                    lastX: 0,
                    lastY: 0
                };
                
                // 데이터 범위
                this.bounds = {
                    minX: 0, maxX: 0,
                    minY: 0, maxY: 0
                };
                
                this.init();
            }
            
            async init() {
                await this.initWebGPU();
                this.setupEventListeners();
                this.render();
            }
            
            async initWebGPU() {
                // WebGPU 지원 확인
                if (!navigator.gpu) {
                    alert('WebGPU를 지원하지 않는 브라우저입니다.');
                    return;
                }
                
                // 어댑터 및 디바이스 생성
                const adapter = await navigator.gpu.requestAdapter();
                this.device = await adapter.requestDevice();
                
                // 캔버스 컨텍스트 설정
                this.context = this.canvas.getContext('webgpu');
                const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
                
                this.context.configure({
                    device: this.device,
                    format: presentationFormat,
                    alphaMode: 'opaque'
                });
                
                // 셰이더 모듈 생성
                const shaderModule = this.device.createShaderModule({
                    code: `
                        struct Uniforms {
                            viewOffset: vec2<f32>,
                            zoom: f32,
                            _padding: f32,
                            color: vec3<f32>,
                            aspectRatio: f32,
                        }
                        
                        @group(0) @binding(0) var<uniform> uniforms: Uniforms;
                        
                        struct VertexOutput {
                            @builtin(position) position: vec4<f32>,
                            @location(0) color: vec3<f32>,
                        }
                        
                        @vertex
                        fn vertexMain(@location(0) pos: vec2<f32>) -> VertexOutput {
                            var output: VertexOutput;
                            
                            // 카메라 변환 적용
                            var transformed = (pos + uniforms.viewOffset) * uniforms.zoom;
                            transformed.x *= uniforms.aspectRatio;
                            
                            output.position = vec4<f32>(transformed, 0.0, 1.0);
                            output.color = uniforms.color;
                            
                            return output;
                        }
                        
                        @fragment
                        fn fragmentMain(@location(0) color: vec3<f32>) -> @location(0) vec4<f32> {
                            return vec4<f32>(color, 1.0);
                        }
                    `
                });
                
                // 유니폼 버퍼 생성
                this.uniformBuffer = this.device.createBuffer({
                    size: 32, // 2*4 + 4 + 4 + 3*4 + 4 + padding = 32 bytes
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                });
                
                // 바인드 그룹 레이아웃
                const bindGroupLayout = this.device.createBindGroupLayout({
                    entries: [{
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: { type: 'uniform' }
                    }]
                });
                
                this.bindGroup = this.device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [{
                        binding: 0,
                        resource: { buffer: this.uniformBuffer }
                    }]
                });
                
                // 파이프라인 생성
                this.pipeline = this.device.createRenderPipeline({
                    layout: this.device.createPipelineLayout({
                        bindGroupLayouts: [bindGroupLayout]
                    }),
                    vertex: {
                        module: shaderModule,
                        entryPoint: 'vertexMain',
                        buffers: [{
                            arrayStride: 8, // 2 floats (x, y)
                            attributes: [{
                                shaderLocation: 0,
                                offset: 0,
                                format: 'float32x2'
                            }]
                        }]
                    },
                    fragment: {
                        module: shaderModule,
                        entryPoint: 'fragmentMain',
                        targets: [{
                            format: presentationFormat
                        }]
                    },
                    primitive: {
                        topology: 'point-list'
                    }
                });
            }
            
            async loadBinaryFile(file) {
                document.getElementById('loading').style.display = 'block';
                
                const arrayBuffer = await file.arrayBuffer();
                const points = new Float32Array(arrayBuffer);
                
                this.pointCount = points.length / 2;
                
                // 데이터 범위 계산
                this.calculateBounds(points);
                
                // 데이터 정규화 (-1 ~ 1 범위로)
                const normalized = this.normalizePoints(points);
                
                // GPU 버퍼 생성
                if (this.vertexBuffer) {
                    this.vertexBuffer.destroy();
                }
                
                this.vertexBuffer = this.device.createBuffer({
                    size: normalized.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
                });
                
                this.device.queue.writeBuffer(this.vertexBuffer, 0, normalized);
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('pointCount').textContent = this.pointCount.toLocaleString();
                
                // 뷰 리셋
                this.resetView();
            }
            
            calculateBounds(points) {
                this.bounds.minX = Infinity;
                this.bounds.maxX = -Infinity;
                this.bounds.minY = Infinity;
                this.bounds.maxY = -Infinity;
                
                for (let i = 0; i < points.length; i += 2) {
                    const x = points[i];
                    const y = points[i + 1];
                    
                    this.bounds.minX = Math.min(this.bounds.minX, x);
                    this.bounds.maxX = Math.max(this.bounds.maxX, x);
                    this.bounds.minY = Math.min(this.bounds.minY, y);
                    this.bounds.maxY = Math.max(this.bounds.maxY, y);
                }
            }
            
            normalizePoints(points) {
                const normalized = new Float32Array(points.length);
                
                const centerX = (this.bounds.minX + this.bounds.maxX) / 2;
                const centerY = (this.bounds.minY + this.bounds.maxY) / 2;
                const rangeX = this.bounds.maxX - this.bounds.minX;
                const rangeY = this.bounds.maxY - this.bounds.minY;
                const maxRange = Math.max(rangeX, rangeY);
                
                for (let i = 0; i < points.length; i += 2) {
                    normalized[i] = (points[i] - centerX) / maxRange * 1.8;
                    normalized[i + 1] = (points[i + 1] - centerY) / maxRange * 1.8;
                }
                
                return normalized;
            }
            
            generateSampleData() {
                // 샤워 헤드 패턴 생성 (원형 격자) - 240만 점
                const pointsPerRing = 1000;
                const rings = 2400;
                const totalPoints = pointsPerRing * rings; // 2,400,000
                
                const points = new Float32Array(totalPoints * 2);
                let idx = 0;
                
                for (let ring = 0; ring < rings; ring++) {
                    const radius = (ring + 1) / rings;
                    for (let i = 0; i < pointsPerRing; i++) {
                        const angle = (i / pointsPerRing) * Math.PI * 2;
                        const r = radius * (0.9 + Math.random() * 0.1); // 약간의 노이즈
                        points[idx++] = Math.cos(angle) * r;
                        points[idx++] = Math.sin(angle) * r;
                    }
                }
                
                // Float32Array를 Blob으로 변환하여 File 객체 생성
                const blob = new Blob([points], { type: 'application/octet-stream' });
                const file = new File([blob], 'sample.bin', { type: 'application/octet-stream' });
                
                this.loadBinaryFile(file);
            }
            
            updateUniforms() {
                const aspectRatio = this.canvas.width / this.canvas.height;

                const uniformData = new Float32Array([
                    this.camera.x, this.camera.y,
                    this.camera.zoom,
                    0, // padding
                    this.pointColor[0], this.pointColor[1], this.pointColor[2],
                    aspectRatio
                ]);

                this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
            }
            
            render() {
                this.updateUniforms();
                
                const commandEncoder = this.device.createCommandEncoder();
                const textureView = this.context.getCurrentTexture().createView();
                
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store'
                    }]
                });
                
                if (this.vertexBuffer && this.pointCount > 0) {
                    renderPass.setPipeline(this.pipeline);
                    renderPass.setBindGroup(0, this.bindGroup);
                    renderPass.setVertexBuffer(0, this.vertexBuffer);
                    renderPass.draw(this.pointCount);
                }
                
                renderPass.end();
                this.device.queue.submit([commandEncoder.finish()]);
                
                // FPS 계산
                this.updateFPS();
                
                requestAnimationFrame(() => this.render());
            }
            
            updateFPS() {
                if (!this.lastTime) {
                    this.lastTime = performance.now();
                    this.frameCount = 0;
                    return;
                }
                
                this.frameCount++;
                const currentTime = performance.now();
                const delta = currentTime - this.lastTime;
                
                if (delta >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / delta);
                    document.getElementById('fps').textContent = fps;
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
            }
            
            resetView() {
                this.camera.x = 0;
                this.camera.y = 0;
                this.camera.zoom = 1.0;
                this.updateZoomDisplay();
            }
            
            updateZoomDisplay() {
                document.getElementById('zoomLevel').textContent = this.camera.zoom.toFixed(2);
            }
            
            setupEventListeners() {
                // 캔버스 리사이즈
                const resizeObserver = new ResizeObserver(() => {
                    this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;
                    this.canvas.height = this.canvas.clientHeight * window.devicePixelRatio;
                });
                resizeObserver.observe(this.canvas);
                
                // 마우스 이벤트
                this.canvas.addEventListener('mousedown', (e) => {
                    this.mouse.down = true;
                    this.mouse.lastX = e.clientX;
                    this.mouse.lastY = e.clientY;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.mouse.down) {
                        const dx = (e.clientX - this.mouse.lastX) / this.canvas.clientWidth * 2;
                        const dy = -(e.clientY - this.mouse.lastY) / this.canvas.clientHeight * 2;
                        
                        this.camera.x += dx / this.camera.zoom;
                        this.camera.y += dy / this.camera.zoom;
                        
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.down = false;
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.mouse.down = false;
                });
                
                // 마우스 휠 (줌)
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.camera.zoom *= zoomFactor;
                    this.camera.zoom = Math.max(0.1, Math.min(10, this.camera.zoom));
                    this.updateZoomDisplay();
                });
                
                // 컨트롤 이벤트
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadBinaryFile(file);
                    }
                });
                
                document.getElementById('generateSample').addEventListener('click', () => {
                    this.generateSampleData();
                });

                document.getElementById('pointColor').addEventListener('input', (e) => {
                    const hex = e.target.value;
                    this.pointColor = [
                        parseInt(hex.substr(1, 2), 16) / 255,
                        parseInt(hex.substr(3, 2), 16) / 255,
                        parseInt(hex.substr(5, 2), 16) / 255
                    ];
                });
                
                document.getElementById('resetView').addEventListener('click', () => {
                    this.resetView();
                });
            }
        }
        
        // 초기화
        const viewer = new PointCloudViewer();
    </script>
</body>
</html>
